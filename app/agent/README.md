# Agent Graph

<p align="center">
  <img src="https://github.com/user-attachments/assets/39a60ecc-7543-4660-8388-b3d2541f2d03" alt="Agent Graph Architecture" width="400"/>
</p>

Below is a brief overview of each node and conditional edge in the agent graph:

### Nodes

- **`oracle`**: Decides to which node between `single_tools`, `chooser`, and `narrator` the execution should continue. This agent is configured to always do a tool call.
- **`single_tools`**: This node contains three tools: `rag_search`, `feedback_provider`, and `points_retriever`.  
  - `rag_search` does a RAG search, meaning it queries the vector database and retrieves `k=5` relevant chunks, returning them in human-readable form to the user.  
  - `feedback_provider` is a tool that, based on a question and a previous answer, returns the correct answer and some feedback.  
  - `points_retriever` gets the user's current point total and returns it with an encouraging message to keep learning.
- **`chooser`**: Chooses a random question from the dataset that's generated by the Q&A Generation Agent.
- **`narrator`**: Starts the execution of the story game. It chooses a random story from the available ones. It also calls an LLM that generates the first message of the story, contextualizing the adventure the user is about to start.
- **`character`**: Decides to which character node the execution should go.
- **`character_first_interaction`**: Invokes an LLM to generate the text response for a character's first interaction, ensuring alignment with its predefined personality. In this exchange, the character introduces themselves and poses a question to the user, facilitating progression to the next stage of the story.
- **`character_loop_interaction`**: Invokes an LLM to generate text responses for loop interactions, aligning with the character's predefined personality. This node activates only when the user's input is not recognized as a valid response (as determined by `response_classifier`). It addresses the user's input (e.g., inquiries about the character's backstory or requests for hints) while reinforcing that answering the question is necessary to progress.
- **`character_life_lost`**: Invokes an LLM to generate a personalized response when a user loses a life. The response includes a message from the character informing the user that their answer was incorrect, displays the remaining *x* lives, incorporates heart emojis corresponding to the number of lives left, and concludes with a motivational message encouraging the user to try again.
- **`character_success_or_failure`**: Calls an LLM that generates the text response for when a user successfully answers the question or loses all three lives, according to the character's personality.
- **`human_interaction`**: Serves as the *human-in-the-loop* component of the graph, pausing execution to allow human intervention — specifically, for the user to provide a response. The user's input is then forwarded to the next node. During this interruption, the graph saves its current state and establishes a *breakpoint* to ensure seamless resumption.
- **`response_classifier`**: Based on the user's input following a character node's response, evaluates whether it is a possible answer to the question.
- **`motivator`**: Executes only when the user has reached a score in the simple question game that is a multiple of five. If so, an LLM generates a congratulatory text encouraging the student to continue.
- **`evaluation_tool`**: Given a question and a user-provided answer, evaluates whether the answer is correct or incorrect.
  - If it is a MCQ (Multiple Choice Question) or TFQ (True/False Question), it compares the user's answer to the AI-generated answer and determines if it is the same or *close enough*.
  - If it is an OEQ (Open-Ended Question), it performs a RAG search with the question as a query and compares the results to the user-provided answer.
  - In either case, it returns the evaluation and the correct answer if the user was wrong.
- **`points_updater_tool`**: Calls a *simple question* exclusive tool that updates the user's total point count if they answer correctly. If the answer is incorrect, nothing happens.
- **`lives_updater_tool`**: Invokes a *story game* exclusive tool that updates the user's life count if they answer incorrectly and redirects execution in a loop to the `human_interaction` node, allowing the user to retry.

### Conditional Edges

- **`should_use_single_tool`**: This conditional edge directs the graph's execution from the `oracle` agent node to a specific node between `single_tools`, `chooser`, and `narrator`, depending on the tool the `oracle` agent chose.
- **`character_or_finish`**: This conditional edge directs the graph's execution from the `narrator` node to the `character` agent node if the story step isn't the last one; otherwise, it finishes with a *last-step* message from the narrator.
- **`which_from_character`**: This conditional edge directs the graph's execution from the `character` agent node to one of the character nodes, depending on the tool the agent decided to call.
- **`response_or_interaction`**: This conditional edge directs the graph's execution from the `response_classifier` node to either `character` or `evaluation_tool`, depending on how the user's input was classified.
- **`points_or_lives`**: This conditional edge directs the graph's execution from the `evaluation_tool` node to either `lives_updater_tool` or `points_updater_tool`, depending on whether the execution was in the story game or not.
- **`should_continue_or_another_try`**: This conditional edge directs the graph's execution from the `lives_updater_tool` node to the `human_interaction` node or ends the execution, depending on whether it was in the story game — and whether the user still has lives left.
